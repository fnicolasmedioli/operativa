<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            margin: 0;
        }
    </style>

    <script src="
https://cdn.jsdelivr.net/npm/force-graph@1.49.1/dist/force-graph.min.js
"></script>
    <link href="
https://cdn.jsdelivr.net/npm/force-graph@1.49.1/src/force-graph.min.css
" rel="stylesheet">
</head>

<body>
    <div id="graph"></div>

    <script>
        // Random tree
        const N = 300;
        const gData = {"nodes":[{"id":"686","text":"prog_1 AND cs_compu_1","esIntermedio":true},{"id":"694","text":"cs_compu_1 AND discreta","esIntermedio":true},{"id":"730","text":"cs_compu_1 AND prog_2","esIntermedio":true},{"id":"758","text":"prog_2 AND discreta","esIntermedio":true},{"id":"986","text":"prog_1 AND discreta","esIntermedio":true},{"id":"1279","text":"prog_2 AND discreta","esIntermedio":true},{"id":"1406","text":"cs_compu_1 AND prog_2 AND discreta","esIntermedio":true},{"id":"1410","text":"algebra_1 AND cs_compu_1","esIntermedio":true},{"id":"1842","text":"prog_1 AND algebra_1","esIntermedio":true},{"id":"1901","text":"prog_1 AND algebra_1 AND cs_compu_1","esIntermedio":true},{"id":"2372","text":"algebra_1 AND prog_2","esIntermedio":true},{"id":"6111","text":"prog_1","esIntermedio":false},{"id":"6113","text":"algebra_1","esIntermedio":false},{"id":"6121","text":"cs_compu_1","esIntermedio":false},{"id":"6122","text":"prog_2","esIntermedio":false},{"id":"6125","text":"discreta","esIntermedio":false},{"id":"0000","text":"inicio","esIntermedio":true}],"links":[{"source":"686","target":"2372","value":"Pa(prog_1) AND Pa(cs_compu_1)"},{"source":"686","target":"6111","value":"Pa(prog_1)"},{"source":"686","target":"6121","value":"Pa(cs_compu_1)"},{"source":"694","target":"6121","value":"Pa(cs_compu_1)"},{"source":"694","target":"6125","value":"Pa(discreta)"},{"source":"730","target":"6121","value":"Pa(cs_compu_1)"},{"source":"730","target":"6122","value":"Pa(prog_2)"},{"source":"758","target":"6122","value":"Pa(prog_2)"},{"source":"758","target":"6125","value":"Pa(discreta)"},{"source":"986","target":"6111","value":"Pa(prog_1)"},{"source":"986","target":"6125","value":"Pa(discreta)"},{"source":"1279","target":"6122","value":"Pa(prog_2)"},{"source":"1279","target":"6125","value":"Pa(discreta)"},{"source":"1406","target":"6121","value":"Pa(cs_compu_1)"},{"source":"1406","target":"6122","value":"Pa(prog_2)"},{"source":"1406","target":"6125","value":"Pa(discreta)"},{"source":"1410","target":"986","value":"Pa(algebra_1) AND Pa(cs_compu_1)"},{"source":"1410","target":"6113","value":"Pa(algebra_1)"},{"source":"1410","target":"6121","value":"Pa(cs_compu_1)"},{"source":"1842","target":"694","value":"Pa(prog_1) AND Pa(algebra_1)"},{"source":"1842","target":"730","value":"Pa(prog_1) AND Pa(algebra_1)"},{"source":"1842","target":"1279","value":"Pa(prog_1) AND Pa(algebra_1)"},{"source":"1842","target":"1406","value":"Pa(prog_1) AND Pa(algebra_1)"},{"source":"1842","target":"6111","value":"Pa(prog_1)"},{"source":"1842","target":"6113","value":"Pa(algebra_1)"},{"source":"1901","target":"758","value":"Pa(prog_1) AND Pa(algebra_1) AND Pa(cs_compu_1)"},{"source":"1901","target":"6111","value":"Pa(prog_1)"},{"source":"1901","target":"6113","value":"Pa(algebra_1)"},{"source":"1901","target":"6121","value":"Pa(cs_compu_1)"},{"source":"2372","target":"6113","value":"Pa(algebra_1)"},{"source":"2372","target":"6122","value":"Pa(prog_2)"},{"source":"0000","target":"686","value":"1"},{"source":"0000","target":"1410","value":"1"},{"source":"0000","target":"1842","value":"1"},{"source":"0000","target":"1901","value":"1"},{"source":"0000","target":"6111","value":"Pa(inicio)"},{"source":"0000","target":"6113","value":"Pa(inicio)"},{"source":"0000","target":"6121","value":"Pa(inicio)"}]}










        // cross-link node objects
        gData.links.forEach(link => {
            const a = gData.nodes.find(node => node.id === link.source);
            const b = gData.nodes.find(node => node.id === link.target);

            if (!a || !b) {
                console.warn("Nodo no encontrado para el enlace:", link);
                return;
            }

            !a.neighbors && (a.neighbors = []);
            !b.neighbors && (b.neighbors = []);
            a.neighbors.push(b);
            b.neighbors.push(a);

            !a.links && (a.links = []);
            !b.links && (b.links = []);
            a.links.push(link);
            b.links.push(link);
        });

        const NODE_R = 8;

        const highlightNodes = new Set();
        const highlightLinks = new Set();
        let hoverNode = null;

        const Graph = new ForceGraph(document.getElementById('graph'))
            .graphData(gData)
            .nodeRelSize(NODE_R)
            .nodeId('id')
            .onLinkHover(link => {
                highlightNodes.clear();
                highlightLinks.clear();
                if (link) {
                    highlightLinks.add(link);
                    highlightNodes.add(link.source);
                    highlightNodes.add(link.target);
                }
            })
            .autoPauseRedraw(false) // keep redrawing after engine has stopped
            .linkWidth(link => highlightLinks.has(link) ? 5 : 1)
            .linkDirectionalParticles(4)
            .linkDirectionalParticleWidth(link => highlightLinks.has(link) ? 4 : 0)
            .linkCurvature('curvature')
            .linkCanvasObjectMode(() => 'after')
            .linkCanvasObject((link, ctx) => {
                const MAX_FONT_SIZE = 4;
                const LABEL_NODE_MARGIN = Graph.nodeRelSize() * 1.5;

                const start = link.source;
                const end = link.target;
                if (typeof start !== 'object' || typeof end !== 'object') return;

                const textPos = { x: start.x + (end.x - start.x) / 2, y: start.y + (end.y - start.y) / 2 };
                const relLink = { x: end.x - start.x, y: end.y - start.y };
                const maxTextLength = Math.sqrt(relLink.x ** 2 + relLink.y ** 2) - LABEL_NODE_MARGIN * 2;

                let textAngle = Math.atan2(relLink.y, relLink.x);
                if (textAngle > Math.PI / 2) textAngle = -(Math.PI - textAngle);
                if (textAngle < -Math.PI / 2) textAngle = -(-Math.PI - textAngle);

                const label = link.value;
                ctx.font = '1px Sans-Serif';
                const fontSize = Math.min(MAX_FONT_SIZE, maxTextLength / ctx.measureText(label).width);
                ctx.font = `${fontSize}px Sans-Serif`;
                const textWidth = ctx.measureText(label).width;
                const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2);

                ctx.save();
                ctx.translate(textPos.x, textPos.y);
                ctx.rotate(textAngle);

                // Cambiar estilo si el link est치 resaltado
                if (highlightLinks.has(link)) {
                    ctx.fillStyle = 'rgba(255, 200, 100, 1)'; // Fondo m치s llamativo
                    ctx.fillRect(-bckgDimensions[0] / 2, -bckgDimensions[1] / 2, ...bckgDimensions);
                    ctx.fillStyle = 'black'; // Texto en negro
                    ctx.font = `bold ${fontSize}px Sans-Serif`; // Negrita
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Fondo normal
                    ctx.fillRect(-bckgDimensions[0] / 2, -bckgDimensions[1] / 2, ...bckgDimensions);
                    ctx.fillStyle = 'darkgrey'; // Texto gris
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, 0, 0);
                ctx.restore();
            })
            .nodeCanvasObjectMode(node => highlightNodes.has(node) ? 'before' : 'after')
            .nodeCanvasObject((node, ctx, globalScale) => {
                if (highlightNodes.has(node)) {
                    // Dibujar anillo de hover antes del nodo
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, NODE_R * 1.4, 0, 2 * Math.PI, false);
                    ctx.fillStyle = node === hoverNode ? 'red' : 'orange';
                    ctx.fill();
                }

                // Dibujar el nodo principal
                ctx.beginPath();
                ctx.arc(node.x, node.y, NODE_R, 0, 2 * Math.PI, false);
                ctx.fillStyle = node.color || 'blue';
                ctx.fill();

                // Mostrar label solo si el nodo est치 en hover o resaltado
                if (highlightNodes.has(node) || node === hoverNode) {
                    const label = node.text || node.id;
                    const fontSize = Math.max(12 / globalScale, 4);
                    ctx.font = `${fontSize}px Sans-Serif`;
                    const textWidth = ctx.measureText(label).width;
                    const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2);

                    // Dibujar fondo del label
                    ctx.fillStyle = node.esIntermedio ? 'rgba(100, 255, 100, 0.8)' : 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - NODE_R - bckgDimensions[1], ...bckgDimensions);

                    // Dibujar texto del label
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = "#000";
                    ctx.fillText(label, node.x, node.y - NODE_R - bckgDimensions[1] / 2);
                }
            })
            .nodePointerAreaPaint((node, color, ctx) => {
                // Define la zona de detecci칩n del nodo
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, NODE_R * 1.5, 0, 2 * Math.PI, false);
                ctx.fill();
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                highlightLinks.clear();

                if (node) {
                    highlightNodes.add(node);
                    node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                    node.links.forEach(link => highlightLinks.add(link));
                }

                hoverNode = node || null;
            })
            .onNodeDragEnd(node => {
                node.fx = node.x;
                node.fy = node.y;
            });

    </script>
</body>